1. ğ(1) - ğ‚ğ¨ğ§ğ¬ğ­ğšğ§ğ­ ğ­ğ¢ğ¦ğ
- The runtime doesn't change regardless of the input size.
- Example: Accessing an element in an array by its index.

2. ğ(ğ¥ğ¨ğ  ğ§) - ğ‹ğ¨ğ ğšğ«ğ¢ğ­ğ¡ğ¦ğ¢ğœ ğ­ğ¢ğ¦ğ
- The runtime grows slowly as the input size increases. Typically seen in algorithms that divide the problem in half with each step.
- Example: Binary search in a sorted array.

3. ğ(ğ§) - ğ‹ğ¢ğ§ğğšğ« ğ­ğ¢ğ¦ğ
- The runtime grows linearly with the input size.
- Example: Finding an element in an array by iterating through each element.

4. ğ(ğ§ ğ¥ğ¨ğ  ğ§) - ğ‹ğ¢ğ§ğğšğ«ğ¢ğ­ğ¡ğ¦ğ¢ğœ ğ­ğ¢ğ¦ğ
- The runtime grows slightly faster than linear time. It involves a logarithmic number of operations for each element in the input.
- Example: Sorting an array using quick sort or merge sort.

5. ğ(ğ§^2) - ğğ®ğšğğ«ğšğ­ğ¢ğœ ğ­ğ¢ğ¦ğ
- The runtime grows proportionally to the square of the input size.
- Example: Bubble sort algorithm which compares and potentially swaps every pair of elements.

6. ğ(2^ğ§) - ğ„ğ±ğ©ğ¨ğ§ğğ§ğ­ğ¢ğšğ¥ ğ­ğ¢ğ¦ğ
- The runtime doubles with each addition to the input. These algorithms become impractical for larger input sizes.
- Example: Generating all subsets of a set.

7. ğ(ğ§!) - ğ…ğšğœğ­ğ¨ğ«ğ¢ğšğ¥ ğ­ğ¢ğ¦ğ
- Runtime is proportional to the factorial of the input size.
- Example: Generating all permutations of a set.